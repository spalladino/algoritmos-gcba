\usepackage[spanish]{babel}
\usepackage[ansinew]{inputenc}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{latexsym}
\usepackage[noend]{algorithmic}
\usepackage{algorithm}

\title{Estructuras de Control}
\author{Algoritmos y Estructuras de Datos \\
Programación Estructurada}
\date{}

\newcommand{\pseudohrule}{\vskip 5pt \hrule}

\newenvironment{pseudo}{
\begin{figure}
\begin{semiverbatim}
}{
\end{semiverbatim}
\end{figure}
}

\setlength{\parskip}{3pt plus 1pt minus 1pt}

\begin{document}

\begin{frame}
\titlepage
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Repaso}

\uncover<1->{
\begin{block}{Especificación}
La especificación de un algoritmo es un contrato entre el programador y el usuario en donde se definen 
cuales son los datos de entrada, la precondición y la postcondición del mismo.
\end{block}
}

\uncover<2->{
\begin{block}{¿Y qué es un algoritmo?}
Una lista de finita intrucciones que permiten hallar la solución a un problema.
\end{block}
}

\uncover<3->{
\begin{block}{¿Y qué son la pre y postcondición?}
Las listas finitas de condiciones que el programa requiere y asegura respectivamente.
\end{block}
}

\uncover<4->{
\begin{block}{¿Cuándo es correcto un algoritmo?}
Cuando dados los datos de entrada tal que se cumple con la precondición podemos asegurar 
que el programa termina y la postcondición se cumple.
\end{block}
}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Estados}

\begin{itemize}
  \item \uncover<1->{Denominamos estado a un punto en la ejecución de un programa.}
  \item \uncover<2->{En cada estado guardamos el valor de las variables, de las constantes y cuál será 
    la próxima instrucción a ejecutarse.}
  \item \uncover<3->{Para decirlo en otras palabras, un estado es una \textit{foto} en la ejecución de un programa.}    
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Componentes}
En la clase pasada vimos algunos componentes de un programa: 
\begin{itemize}
\item instrucciones, 
\item variables, 
\item constantes, 
\item literales, 
\item tipos de datos, 
\item operaciones básicas...
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Pseudocódigo}

\begin{block}{¿Qué es el pseudocódigo?}
Cuando queremos escribir un algoritmo, pero no atarnos a algún lenguaje de máquina en particular (como C++ o Python), usamos un pseudocódigo para comunicar el algoritmo entre nosotros.
\end{block}

\uncover<2->{
El pseudocódigo no tiene por qué ser entendible por una computadora, pero sí debe ser claro y no ambiguo para otra persona que lo lee, y debe ser fácil pasarlo a un lenguaje de máquina.
}

\uncover<3->{
Hay muchos pseudocódigos distintos, depende qué sintaxis se use. Lo importante es que nos pongamos de acuerdo y usemos todos las mismas reglas.
}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Pseudocódigo}

Vamos a identificar nuevamente los componentes que ya vimos en nuestro pseudocódigo:

\begin{pseudo}
Calcular la longitud de una circunferencia dado el radio
Entrada: el radio del círculo r
Pre: el radio r debe ser positivo
Post: la salida es la longitud de la circunferencia con radio r
\pseudohrule
const PI = 3.14159265
circunferencia = PI * 2 * r
devolver circunferencia
\end{pseudo}

No olvidarse nunca la especificación del algoritmo!
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Instrucciones}
Recordemos la definición de instrucción:
\begin{block}{Qué es una instrucción?}
Una \textbf{instrucción} es una operación que o bien produce una transformación sobre los elementos del programa, o produce una modificación en el \alert<2>{flujo de control} en la ejecución del programa.
\end{block}

\uncover<2->{
\begin{block}{Cuál es el flujo de control normal de un programa?}
Salvo que haya \alert<3>{estructuras de control} que modifiquen el flujo del programa, ejecutamos las instrucciones secuencialmente. 
\end{block}
}

\uncover<3->{
\begin{block}{Qué son las estructuras de control?}
Las estructuras de control nos permiten modificar el flujo de instrucciones de un programa. El ejemplo más sencillo es el \alert<4>{condicional}.
\end{block}
}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Condicional}

El condicional es una estructura de control que nos permite indicar que una serie de instrucciones debe ejecutarse solamente al cumplirse determinada condición.

\begin{pseudo}
\textbf{si} condicion
  instrucciones a ejecutar si se cumple la condicion
\textbf{fin}
\end{pseudo}

\uncover<2->{En Python, esta instrucción es el \textbf{if}}

\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Ejemplo}

\begin{pseudo}
Devolver los primeros 5 caracteres de un string \textit{s} en mayuscula
Entrada: string \textit{s}
Pre:  \textit{s} no debe ser vacio
Post: devuelve los primeros 5 caracteres de \textit{s} en mayuscula
      si \textit{s} tiene menos de 5 caracteres, devuelve todos
\pseudohrule
si longitud(s) > 5
  s = principio(s, 5)
end
mayus =  mayusculas(s)
devolver mayus
\end{pseudo}

\end{frame} 

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Ejemplo}
Observemos cómo es el flujo de control del programa si \textit{s} es 'mapa':
\begin{itemize}
\item Estado 0: \texttt{s: "mapa"}\\
Instruccion actual \texttt{si longitud(s) $>$ 5}\\
Ejecuta \texttt{longitud(s) $>$ 5}, es falso, salta al final del bloque
\item Estado 1: \texttt{s: "mapa"}\\
Instruccion actual \texttt{mayus =  mayusculas(s)}\\
Ejecuta \texttt{mayusculas(s)} y asigna el resultado a \texttt{mayus}
\item Estado 2: \texttt{s: "mapa", mayus: "MAPA"}\\
Instruccion actual \texttt{devolver mayus}\\
El programa devuelve el contenido de \texttt{mayus} y finaliza
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Ejemplo}
Veamos ahora con una entrada diferente, como 'constantinopla':
\begin{itemize}
\item Estado 0: \texttt{s: 'constantinopla'}\\
Instruccion actual \texttt{si longitud(s) $>$ 5}\\
Ejecuta \texttt{longitud(s) $>$ 5}, es verdadero,
\item Estado 1: \texttt{s: 'constantinopla'}\\
\alert<2>{Instruccion actual \texttt{s = principio(s, 5)}\\
Toma los primeros 5 caracteres de \texttt{s} y reasigna el resultado a \texttt{s}}
\item Estado 2: \texttt{s: 'const'}\\
Instruccion actual \texttt{mayus =  mayusculas(s)}\\
Ejecuta \texttt{mayusculas(s)} y asigna el resultado a \texttt{mayus}
\item Estado 2: \texttt{s: 'const', mayus: 'CONST'}\\
Instruccion actual \texttt{devolver mayus}\\
El programa devuelve el contenido de \texttt{mayus} y finaliza
\end{itemize}

La serie de instrucciones que se ejecutó en ambos casos es distinta.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Si no...}

Qué pasa si queremos ejecutar algo distinto si no se cumple la condición? Podríamos hacer:
\begin{pseudo}
si condicion
  unas instrucciones 
fin
si no se cumple condicion
  otras instrucciones
fin
\end{pseudo}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Si no...}

Por conveniencia, definimos el \texttt{si no}:
\begin{pseudo}
si condicion
  unas instrucciones 
\textbf{si no}
  otras instrucciones
fin
\end{pseudo}

\uncover<2->{En Python, esta instrucción es el \textbf{else}}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Ejemplo}

Queremos un programa sencillo que imprima la mitad de un número si es par, o que indique \textit{impar} si no lo es.

\begin{pseudo}
Devuelve mitad de un numero par
Entrada: un entero \textit{n}
Pre:  \textit{n} debe ser mayor a cero
Post: la salida indica \textit{n/2} si es par, o \textit{impar} si \textit{n} es impar
\pseudohrule
si resto(n,2) == 0
  imprimir n/2
si no
  imprimir \textit{impar}
fin
\end{pseudo}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Repeticiones}

Vamos a escribir un programa que dado un string, devuelva otro formado por repetir \alert{\only<1>{dos}\only<2>{tres}\only<3>{cuatro}} veces el original.

\begin{pseudo}
Repite un string \alert{\only<1>{dos}\only<2>{tres}\only<3>{cuatro}} veces
Entrada: un string \textit{str}
Pre:  \textit{str} debe ser no vacío
Post: la salida es \textit{str} \textit{str} \uncover<2->{\alert{\textit{str}}} \uncover<3->{\alert{\textit{str}}}
\pseudohrule
res = str
res = res + str
\only<2->{\alert{res = res + str}}
\only<3->{\alert{res = res + str}}
devolver res
\end{pseudo}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Repeticiones}

Para generalizar los programas anteriores, podríamos escribir un programa tal que dado un string a repetir y un \textbf{número de repeticiones}, devuelva el string repetido esa cantidad de veces. 

Necesitamos una \textbf{estructura de control} que nos permita repetir una serie de instrucciones una determinada cantidad de veces.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Presentando el Para}

El \texttt{para} es una estructura de control que nos permite ejecutar un conjunto de instrucciones para un rango de valores que toma una variable de tipo entero.

\begin{pseudo}
para i de 1 a 10
  \alert<2>{conjunto de instrucciones a repetir}
fin
\end{pseudo}

\uncover<2>{En el ejemplo, el conjunto de instrucciones se repite 10 veces, para cada valor que toma \texttt{i}}

\uncover<3>{En Python, esta instrucción se llama \texttt{for}, y se suele usar como \texttt{for i in range(1..11)}}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Reescribiendo el ejemplo}

Reescribamos el ejemplo para que repita el string una cantidad de veces indicada como entrada.

\begin{pseudo}
Repite un string \textit{n} veces
Entrada: string \textit{str}, entero \textit{n}
Pre:  \textit{str} no vacío; \textit{n} mayor a cero
Post: la salida es \textit{str} repetido \textit{n} veces
\pseudohrule
res = ''
para i de 1 a n
  res = res + str
fin
devolver res
\end{pseudo}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Invariante de ciclo}
Junto con las estructuras de control que nos permiten repetir una serie de instrucciones cierta cantidad de veces, definimos los \textbf{invariantes de ciclo}.

\uncover<2->{
\begin{block}{Qué es el invariante de un ciclo?}
El invariante de un ciclo es una propiedad que se mantiene en cada iteración del ciclo, y nos ayuda a probar la correctitud del programa que estamos escribiendo.
\end{block}
}

\uncover<3>{Veamoslo en nuestro ejemplo analizando la sucesión de estados del programa para una entrada dada...}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Estados en nuestro ejemplo}

Supongamos que repetimos el string 'la' 3 veces:

\begin{itemize}[<+->]
\item Estado 0: \texttt{str: 'la', n: 3}\\
Instrucción actual \texttt{res = ''}\\
\item Estado 1: \texttt{str: 'la', n: 3, \alert<2>{res: ''}}\\
\texttt{para i de 1 a n}\\
\item Estado 2: \texttt{str: 'la', n: 3, res: '', \alert<3>{i: 1}}\\
\texttt{res = res + str}\\
\item Estado 3: \texttt{str: 'la', n: 3, \alert<4>{res: 'la'}, i: 1}\\
\texttt{para i de 1 a n}\\
\item Estado 4: \texttt{str: 'la', n: 3, res: 'la', \alert<5>{i: 2}}\\
\texttt{res = res + str}\\
\item Estado 5: \texttt{str: 'la', n: 3, \alert<6>{res: 'lala'}, i: 2}\\
\texttt{para i de 1 a n}\\
\item Estado 6: \texttt{str: 'la', n: 3, res: 'lala', \alert<7>{i: 3}}\\
\texttt{res = res + str}\\
\item Estado 7: \texttt{str: 'la', n: 3, \alert<8>{res: 'lalala'}, i: 3}\\
\texttt{para i de 1 a n}\\
\item Estado 8: \texttt{str: 'la', n: 3, res: 'lalala'}\\
\texttt{devolver res}\\
Devuelve 'lalala' como resultado
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Determinando el invariante}
Observemos que para cada uno de los estados dentro del ciclo, se cumple que al finalizar la iteración \texttt{i}, la variable \texttt{res} contiene el string de entrada repetido \texttt{i} veces.

Este invariante de ciclo es lo que nos permite demostrar que al terminar el ciclo, la variable de resultado tiene \texttt{n} veces repetido el string.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Usos del invariante}
\begin{block}{De qué nos sirve el invariante de un ciclo?}
Expresar el invariante del ciclo nos permite:
\begin{itemize}
\item ver que el algoritmo es correcto con más facilidad
\item detectar errores que hayamos cometido
\item entender qué hace código ajeno más rápidamente
\end{itemize}
\end{block}

\uncover<2>{
Incluso existen herramientas de análisis automático de código que, si les proveemos un invariante de ciclo, pueden demostrar la
correctitud de un algoritmo en base a una especificación.
}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Invariante != Especificación}
\begin{block}{No confundir!}
Un error muy común es considerar el invariante como parte de la especificación.

A no confundir! La especificación, compuesta por la pre y la post condiciones, indica \textbf{qué} hace el algoritmo, mientras que el invariante de ciclo está atado a \textbf{cómo} lo hace, dando información extra sobre un conjunto de instrucciones del programa.
\end{block}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Variable de control}

La \textit{variable de control} o \textit{variable de iteración} es aquella sobre la cual opera el ciclo, incrementándola a cada iteración.

Podemos usar el valor de la variable de control \textbf{dentro} del cuerpo del ciclo en nuestras operaciones.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Usando el valor de la variable de control}

Construyamos un programa que sume los numeros de 1 hasta n:

\begin{pseudo}
Suma los numeros de 1 a \textit{n}
Entrada: entero \textit{n}
Pre:  \textit{n} es mayor a cero
Post: devuelve la suma de 1 a \textit{n}
\pseudohrule
res = 0
para i de 1 a n
  res = res + i
fin
devolver res
\end{pseudo}

\uncover<2>{
\begin{block}{Invariante del ciclo}
La variable \texttt{res} contiene la suma de los numeros de 1 hasta \texttt{i} en la iteración \texttt{i}.
\end{block}
}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Paso a paso}

Podemos definir también cuál queremos que sea el paso (\textit{step}) de la iteración, es decir, de a cuánto se incrementa la variable de control.

\pause

Por defecto el paso es 1:

\begin{pseudo}
para i de 1 a 4
  imprimir i
fin
\pseudohrule
Salida:
1
2
3
4
\end{pseudo}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Paso a paso}

Podemos aumentarlo para saltear valores en la iteración:

\begin{pseudo}
para i de 1 a 4 cada 2
  imprimir i
fin
\pseudohrule
Salida:
1
3
\end{pseudo}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Paso a paso}

E incluso podemos definir ciclos que vayan de atrás para adelante:

\begin{pseudo}
para i de 4 a 1
  imprimir i
end
\pseudohrule
Salida:
4
3
2
1
\end{pseudo}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Hacia ciclos más generales}

\begin{block}{Resolver el siguiente problema:}
Devolver el menor entero múltiplo de tres que termine en 4.
\end{block}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Usando un ciclo for}

Podemos intentar resolverlo implementando un ciclo, que itere sobre los múltiplos de tres, y nos devuelva el primer número terminado en 4 que encuentre.

\begin{pseudo}
Encuentra el menor entero divisible por 3 que termina en 4
\pseudohrule
para i de 0 a \alert<2>{n} cada 3
  si i termina en 4
    devolver i
  fin
fin
\end{pseudo}

\uncover<2>{\alert{Quién es $n$?}}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Limitaciones del for}

En el caso anterior no sabemos hasta qué valor tendríamos que iterar para encontrar el número que nos piden. 

El ciclo \textbf{for} itera sobre un rango de números ya definido al empezar el ciclo, esta limitación nos impide usarlo para resolver este problema.

Vamos a requerir una nueva \textit{estructura de control}...

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{While}

El ciclo \texttt{mientras} (while) ejecuta una serie de instrucciones mientras se cumpla una determinada condición. En el momento en que la condición es falsa, sale del ciclo y continúa con el programa.

\begin{pseudo}
mientras condicion
  instrucciones a ejecutar mientras la condicion sea verdadera
fin
\end{pseudo}

El \textit{while} es mucho más flexible, pues nos permite ejecutar un ciclo usando cualquier condición para indicar su terminación. También por esto es más peligroso, pues si no se utiliza con cuidado puede ser que \textbf{nunca termine}.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{While}

Utilizando el while para el ejemplo:

\begin{pseudo}
Encuentra el menor entero divisible por 3 que termina en 4
\pseudohrule
i = 0
mientras i no termine en 4
  i = i + 3
fin
devolver i
\end{pseudo}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Resumiendo...}

\begin{itemize}
\item Condicionales: \texttt{if}, \texttt{else}
\item Ciclos \texttt{for}
\item Invariante de ciclo
\item Ciclos \texttt{while}
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

